<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="hell@world" />
        <meta name="copyright" content="hell@world" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content=", rust, " />

<meta property="og:title" content="Rust matching, mutation, moves 杂谈 "/>
<meta property="og:url" content="/rust-matching-mutation-moves-za-tan.html" />
<meta property="og:description" content="翻译: By rustup(欢迎转载分享,请注明出处) 原文: Mixing matching, mutation, and moves in Rust Rust 语言的一个主要目标是保证系统编程安全. 系统编程往往意味着命令式编程,也往往带来副作用, 比如共享变量等等. 为了提供安全性, Rust 程序和数据类型构造成允许进行静态检查来保证代码可靠.Rust 结合各种特性和约束共同作用, 编程轻易就通过静态检查,这样又保证安全. 像 Rust深度引入的 ownership 的概念. Rust match 表达式就是这样的一种特性和约束共存有意思的结合体. match 表达式获取一个输入之, 进行归类, 然后跳转到进行处理的代码. 本文将探讨 Rust 是如何通过 match 处理数据. match 和 搭配使用的 enum 比较关键的结合点如下: 结构化模式匹配: 较 c/java ..." />
<meta property="og:site_name" content="代码火花" />
<meta property="og:article:author" content="hell@world" />
<meta property="og:article:published_time" content="2015-05-06T00:00:00" />
<meta name="twitter:title" content="Rust matching, mutation, moves 杂谈 ">
<meta name="twitter:description" content="翻译: By rustup(欢迎转载分享,请注明出处) 原文: Mixing matching, mutation, and moves in Rust Rust 语言的一个主要目标是保证系统编程安全. 系统编程往往意味着命令式编程,也往往带来副作用, 比如共享变量等等. 为了提供安全性, Rust 程序和数据类型构造成允许进行静态检查来保证代码可靠.Rust 结合各种特性和约束共同作用, 编程轻易就通过静态检查,这样又保证安全. 像 Rust深度引入的 ownership 的概念. Rust match 表达式就是这样的一种特性和约束共存有意思的结合体. match 表达式获取一个输入之, 进行归类, 然后跳转到进行处理的代码. 本文将探讨 Rust 是如何通过 match 处理数据. match 和 搭配使用的 enum 比较关键的结合点如下: 结构化模式匹配: 较 c/java ...">

        <title>Rust matching, mutation, moves 杂谈  · 代码火花
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="/theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css" href="/theme/tipuesearch/tipuesearch.css" media="screen">
        <link rel="stylesheet" type="text/css" href="/theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css" href="/theme/css/custom.css" media="screen">
    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container-fluid">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="/"><span class=site-name>代码火花</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="">Home</a></li>
                            <li ><a href="/categories.html">Categories</a></li>
                            <li ><a href="/tags.html">Tags</a></li>
                            <li ><a href="/archives.html">Archives</a></li>
                            <li><form class="navbar-search" action="/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page-header span10 offset2">
    <h1><a href="/rust-matching-mutation-moves-za-tan.html"> Rust matching, mutation, moves 杂谈  </a></h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">

            
            <p>翻译: By rustup(欢迎转载分享,请注明出处)</p>
<p>原文: <a href="http://blog.rust-lang.org/2015/04/17/Enums-match-mutation-and-moves.html" target="_blank">Mixing matching, mutation, and moves in Rust</a></p>
<p>Rust 语言的一个主要目标是保证系统编程安全. 系统编程往往意味着命令式编程,也往往带来副作用, 比如共享变量等等.</p>
<p>为了提供安全性, Rust 程序和数据类型构造成允许进行静态检查来保证代码可靠.Rust 结合各种特性和约束共同作用, 编程轻易就通过静态检查,这样又保证安全. 像 Rust深度引入的 ownership 的概念.</p>
<p>Rust match 表达式就是这样的一种特性和约束共存有意思的结合体. match 表达式获取一个输入之, 进行归类, 然后跳转到进行处理的代码.</p>
<p>本文将探讨 Rust 是如何通过 match 处理数据. match 和 搭配使用的 enum 比较关键的结合点如下:</p>
<ul>
<li>结构化模式匹配: 较 c/java 的 switch 更句工效的分支解析</li>
<li>全部分支分析: 保证没有被忽略的支路.</li>
<li>match 涵盖命令式和函数式编程. 可以继续使用 break 语句, 赋值等等. 不会被强迫接受面向表达式思想</li>
<li>根据需要匹配值为 borrows 或者 moves 的类型: Rust 鼓励开发者慎重考虑 ownership 和 borrowing. 为了确保不被强迫永久出让值的 ownership, match 设计初衷就支持只 borrow ing 子结构(和 moving 子结构相对应).</li>
</ul>
<p>下面分别对每一项进行细讲. 首先介绍下本文所探讨内容的基础: match 是什么样子的, 它是如何工作的.</p>
<h3>match 的基本原理</h3>
<p>Rust match 表达式具有如下格式</p>
<div class="highlight"><pre><span class="n">match</span> <span class="n">INPUT_EXPRESSION</span> <span class="p">{</span>
    <span class="n">PATTERNS_1</span> <span class="o">=&gt;</span> <span class="n">RESULT_EXPRESSION_1</span><span class="p">,</span>
    <span class="n">PATTERNS_2</span> <span class="o">=&gt;</span> <span class="n">RESULT_EXPRESSION_2</span><span class="p">,</span>
    <span class="p">...</span>
    <span class="n">PATTERNS_n</span> <span class="o">=&gt;</span> <span class="n">RESULT_EXPRESSION_n</span>
<span class="p">}</span>
</pre></div>


<p>每一个 PATTERNS_i 都至少包含一种模式. 一个模式表示可能的 INPUT_EXPRESSION 的值的集合. PATTERNS =&gt; RESULT_EXPRESSION 语法被称作一个匹配分支, 或者简称分支.</p>
<p>模式可以匹配像 integers 或者 characters 这类简单的值. 也可以匹配用户通过 enmu 自定义的符号数据.</p>
<p>下面的代码演示猜数字游戏中如何通过上一次的猜测,生成下一次猜测数字(简单实现). </p>
<div class="highlight"><pre><span class="k">enum</span> <span class="n">Answer</span> <span class="p">{</span>
    <span class="n">Higher</span><span class="p">,</span>
    <span class="n">Lower</span><span class="p">,</span>
    <span class="n">Bingo</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">fn</span> <span class="n">suggest_guess</span><span class="p">(</span><span class="n">prior_guess</span><span class="o">:</span> <span class="n">u32</span><span class="p">,</span> <span class="n">answer</span><span class="o">:</span> <span class="n">Answer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">match</span> <span class="n">answer</span> <span class="p">{</span>
        <span class="n">Answer</span><span class="o">::</span><span class="n">Higher</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;maybe try {} next&quot;</span><span class="p">,</span> <span class="n">prior_guess</span> <span class="o">+</span> <span class="mi">10</span><span class="p">),</span>
        <span class="n">Answer</span><span class="o">::</span><span class="n">Lower</span>  <span class="o">=&gt;</span> <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;maybe try {} next&quot;</span><span class="p">,</span> <span class="n">prior_guess</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">Answer</span><span class="o">::</span><span class="n">Bingo</span>  <span class="o">=&gt;</span> <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;we won with {}!&quot;</span><span class="p">,</span> <span class="n">prior_guess</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="n">fn</span> <span class="n">demo_suggest_guess</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">suggest_guess</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">Answer</span><span class="o">::</span><span class="n">Higher</span><span class="p">);</span>
    <span class="n">suggest_guess</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">Answer</span><span class="o">::</span><span class="n">Lower</span><span class="p">);</span>
    <span class="n">suggest_guess</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="n">Answer</span><span class="o">::</span><span class="n">Bingo</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>不出意外的话, 本文所有的代码都可以直接执行. 可以复制-剪切代码片段到 demo.rs . 使用 --test 编译该文件, 之后执行生成的二进制文件以查看结果.</p>
<p>模式也可以通过相符合的模式来匹配结构化的数据(tuples,slices,用户自定义数据类型). 在这些模式中,可以将输入的值的部分绑定到本地变量, 这些变量就可以在匹配到的表达式中使用.</p>
<p>_是一种特殊的模式, 它可以匹配一个单独的值. 也经常被用做通配. 特殊的 .. 模式广泛匹配一系列的值或者是名字/值对.</p>
<p>同时间,可以通过使用 | 分隔模式,将多个模式折叠进一个分支. 这样的话, 这个分支可以匹配其中任意一个模式.</p>
<p>这些特性可以通过下面的改进版猜数字游戏进行说明.</p>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">GuessState</span> <span class="p">{</span>
    <span class="nl">guess:</span> <span class="n">u32</span><span class="p">,</span>
    <span class="nl">answer:</span> <span class="n">Answer</span><span class="p">,</span>
    <span class="nl">low:</span> <span class="n">u32</span><span class="p">,</span>
    <span class="nl">high:</span> <span class="n">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">fn</span> <span class="n">suggest_guess_smarter</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="n">GuessState</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">match</span> <span class="n">s</span> <span class="p">{</span>
        <span class="c1">// First arm only fires on Bingo; it binds `p` to last guess.</span>
        <span class="n">GuessState</span> <span class="p">{</span> <span class="n">answer</span><span class="o">:</span> <span class="n">Answer</span><span class="o">::</span><span class="n">Bingo</span><span class="p">,</span> <span class="n">guess</span><span class="o">:</span> <span class="n">p</span><span class="p">,</span> <span class="p">..</span> <span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// ~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~  ~~~~~~~~  ~~</span>
        <span class="c1">//     |                 |                 |     |</span>
        <span class="c1">//     |                 |                 |     Ignore remaining fields</span>
        <span class="c1">//     |                 |                 |</span>
        <span class="c1">//     |                 |      Copy value of field `guess` into local variable `p`</span>
        <span class="c1">//     |                 |</span>
        <span class="c1">//     |   Test that `answer field is equal to `Bingo`</span>
        <span class="c1">//     |</span>
        <span class="c1">//  Match against an instance of the struct `GuessState`</span>

            <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;we won with {}!&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>

        <span class="c1">// Second arm fires if answer was too low or too high.</span>
        <span class="c1">// We want to find a new guess in the range (l..h), where:</span>
        <span class="c1">//</span>
        <span class="c1">// - If it was too low, then we want something higher, so we</span>
        <span class="c1">//   bind the guess to `l` and use our last high guess as `h`.</span>
        <span class="c1">// - If it was too high, then we want something lower; bind</span>
        <span class="c1">//   the guess to `h` and use our last low guess as `l`.</span>
        <span class="n">GuessState</span> <span class="p">{</span> <span class="n">answer</span><span class="o">:</span> <span class="n">Answer</span><span class="o">::</span><span class="n">Higher</span><span class="p">,</span> <span class="n">low</span><span class="o">:</span> <span class="n">_</span><span class="p">,</span> <span class="n">guess</span><span class="o">:</span> <span class="n">l</span><span class="p">,</span> <span class="n">high</span><span class="o">:</span> <span class="n">h</span> <span class="p">}</span> <span class="o">|</span>
        <span class="n">GuessState</span> <span class="p">{</span> <span class="n">answer</span><span class="o">:</span> <span class="n">Answer</span><span class="o">::</span><span class="n">Lower</span><span class="p">,</span>  <span class="n">low</span><span class="o">:</span> <span class="n">l</span><span class="p">,</span> <span class="n">guess</span><span class="o">:</span> <span class="n">h</span><span class="p">,</span> <span class="n">high</span><span class="o">:</span> <span class="n">_</span> <span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// ~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~   ~~~~~~  ~~~~~~~~  ~~~~~~~</span>
        <span class="c1">//     |                 |                 |        |        |</span>
        <span class="c1">//     |                 |                 |        |    Copy or ignore</span>
        <span class="c1">//     |                 |                 |        |    field `high`,</span>
        <span class="c1">//     |                 |                 |        |    as appropriate</span>
        <span class="c1">//     |                 |                 |        |</span>
        <span class="c1">//     |                 |                 |  Copy field `guess` into</span>
        <span class="c1">//     |                 |                 |  local variable `l` or `h`,</span>
        <span class="c1">//     |                 |                 |  as appropriate</span>
        <span class="c1">//     |                 |                 |</span>
        <span class="c1">//     |                 |    Copy value of field `low` into local</span>
        <span class="c1">//     |                 |    variable `l`, or ignore it, as appropriate</span>
        <span class="c1">//     |                 |</span>
        <span class="c1">//     |   Test that `answer field is equal</span>
        <span class="c1">//     |   to `Higher` or `Lower`, as appropriate</span>
        <span class="c1">//     |</span>
        <span class="c1">//  Match against an instance of the struct `GuessState`</span>

            <span class="n">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">((</span><span class="n">h</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
            <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;lets try {} next&quot;</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="n">fn</span> <span class="n">demo_guess_state</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">suggest_guess_smarter</span><span class="p">(</span><span class="n">GuessState</span> <span class="p">{</span><span class="n">guess</span><span class="o">:</span> <span class="mi">20</span><span class="p">,</span>
                            <span class="nl">answer:</span> <span class="n">Answer</span><span class="o">::</span><span class="n">Lower</span><span class="p">,</span>
                            <span class="nl">low:</span> <span class="mi">10</span><span class="p">,</span> <span class="n">high</span><span class="o">:</span> <span class="mi">1000</span><span class="p">});</span>
<span class="p">}</span>
</pre></div>


<p>这种同时能进行分支解析, 以及绑定输入的子结构的能力, 使得代码更强壮, 清晰精准, 阅读者可以专注于当前分支进行的数据相关的操作.</p>
<p>这就是对 match 表达式的简要概括.</p>
<p>那么 Rust 提供的的 ownership 和安全机制跟 enum 之间有什么交集呢?</p>
<h3>全面的分支解析</h3>
<p><em>…when you have eliminated all which is impossible, then whatever remains, however improbable, must be the truth.</em></p>
<p><em>– Sherlock Holmes (Arthur Conan Doyle, “The Blanched Soldier”)</em></p>
<p>解决复杂问题的一种有效的办法是将它分隔成单独的分支, 并独立的分析每一种情况. 通过这种方法解决的问题, 必须要进行全面分类, 所有的分支加起来要能够覆盖所有的可能场景.
使用 enum 和 match 可以辅助该过程, 因为 match 强制进行全面的分支解析. 每一个可能的输入都必须被至少一个分之模式覆盖.</p>
<p>这能够帮助寻找程序的逻辑 bug , 并保证 match 表达式的值是被精心定义的.</p>
<p>因此, 在下面的例子中代码会被编译时驳回.</p>
<div class="highlight"><pre><span class="n">fn</span> <span class="nf">suggest_guess_broken</span><span class="p">(</span><span class="n">prior_guess</span><span class="o">:</span> <span class="n">u32</span><span class="p">,</span> <span class="n">answer</span><span class="o">:</span> <span class="n">Answer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">next_guess</span> <span class="o">=</span> <span class="n">match</span> <span class="n">answer</span> <span class="p">{</span>
    <span class="n">Answer</span><span class="o">::</span><span class="n">Higher</span> <span class="o">=&gt;</span> <span class="n">prior_guess</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">Answer</span><span class="o">::</span><span class="n">Lower</span>  <span class="o">=&gt;</span> <span class="n">prior_guess</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="c1">// ERROR: non-exhaustive patterns: `Bingo` not covered</span>
    <span class="p">};</span>
    <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;maybe try {} next&quot;</span><span class="p">,</span> <span class="n">next_guess</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>许多别的语言(ML 和 Scheme 各种基于宏的 match 实现)提供一个模式匹配结构, 但并不是所有的都会有这个约束.</p>
<p>Rust 因一下原因而加入该约束:</p>
<ul>
<li>第一, 正如上面提到的, 将问题分解成分支对只是给出了一种通用的解决方案. 全面检查机制才能够暴露逻辑错误.</li>
<li>其次, 全面检查机制是重构的好帮手. 在开发过程中, 我回经常的为 enum 添加一些新的变量定义, 全面检查机制能够帮忙指出来所有只匹配之前的 enum 数据的地方.</li>
<li>第三, 鉴于 match 只是一种表达式方式, 全面性保证这种表达式能够匹配到正确的类型, 也能够跳转到程序其它的地方.</li>
</ul>
<h3>跳出 match</h3>
<p>下面的代码是 suggest_guess_broken 函数的修正版本. 它直接的演示了什么叫做 '跳转到其它地方'</p>
<div class="highlight"><pre><span class="n">fn</span> <span class="nf">suggest_guess_fixed</span><span class="p">(</span><span class="n">prior_guess</span><span class="o">:</span> <span class="n">u32</span><span class="p">,</span> <span class="n">answer</span><span class="o">:</span> <span class="n">Answer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">next_guess</span> <span class="o">=</span> <span class="n">match</span> <span class="n">answer</span> <span class="p">{</span>
        <span class="n">Answer</span><span class="o">::</span><span class="n">Higher</span> <span class="o">=&gt;</span> <span class="n">prior_guess</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">Answer</span><span class="o">::</span><span class="n">Lower</span>  <span class="o">=&gt;</span> <span class="n">prior_guess</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">Answer</span><span class="o">::</span><span class="n">Bingo</span>  <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;we won with {}!&quot;</span><span class="p">,</span> <span class="n">prior_guess</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;maybe try {} next&quot;</span><span class="p">,</span> <span class="n">next_guess</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="n">fn</span> <span class="nf">demo_guess_fixed</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">suggest_guess_fixed</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">Answer</span><span class="o">::</span><span class="n">Higher</span><span class="p">);</span>
    <span class="n">suggest_guess_fixed</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">Answer</span><span class="o">::</span><span class="n">Lower</span><span class="p">);</span>
    <span class="n">suggest_guess_fixed</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="n">Answer</span><span class="o">::</span><span class="n">Bingo</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Suggest_guess_fixed 函数会处理一些分支,(并快速的从函数中返回). 这个过程中,必须计算其它分支路中的需要的匹配值,然后跌落到函数体中输出提示的地方.</p>
<p>可以通过添加特殊的分支处理而不必担心忽略了某个分支,因为 match 会强制全面进行分支解析.</p>
<h3>代数数据类型(Algebraic Data Types) 和结构不变量(Structural Invariants)</h3>
<p><a href="http://en.wikipedia.org/wiki/Algebraic_data_type" target="_blank"> 代数数据类型 </a> 简要的表达数据的分类, 并允许进行富结构不变量编码. Rust 使用 enum 和 struct 来实现这个目标.</p>
<p>enum 类型允许定义互斥类型的值.  以上例子展示如何在简单符号标签中使用 enum , 但是在 Rust 中, enum 可以定义更丰富的数据类型.</p>
<p>以二叉树为例,二叉树要么是一个叶子, 要么是一个内部的能关联到两个子树的 node . 可以这样用 integer 来编码一个二叉树.</p>
<div class="highlight"><pre><span class="nx">enum</span> <span class="nx">BinaryTree</span> <span class="p">{</span>
    <span class="nx">Leaf</span><span class="p">(</span><span class="nx">i32</span><span class="p">),</span>
    <span class="nx">Node</span><span class="p">(</span><span class="nx">Box</span><span class="o">&lt;</span><span class="nx">BinaryTree</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">i32</span><span class="p">,</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">BinaryTree</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>(Box(V) 类型描述引用到堆分配的实例 V, 如果你拥有一个 Box(V), 你可以拥有它包含的 V, 可以修改它以及借出引用等. 当结束使用 box 并跌出生存上下文(scope), 它回自动清理相关堆分配的资源V )</p>
<p>上面的 enum 定义保证如果我们给定一个 BinaryTree, 它总是会进入上面两种情况. 绝对不会出现一个没有左子树的 BinaryTree::Node . 而且没必要对 null 进行检查.</p>
<p>有必要进行检查的是给定的 BinaryTree 到底是一个 Leaf 还是一个 Node. 但是编译器回静态的保证这种检查. 你绝对不会意外的将 Leaf 解释成 Node, 反过来亦然.</p>
<p>下面是函数使用 enum 计算一棵树中所有 integers 的总和.</p>
<div class="highlight"><pre><span class="n">fn</span> <span class="nf">tree_weight_v1</span><span class="p">(</span><span class="n">t</span><span class="o">:</span> <span class="n">BinaryTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i32</span> <span class="p">{</span>
    <span class="n">match</span> <span class="n">t</span> <span class="p">{</span>
        <span class="n">BinaryTree</span><span class="o">::</span><span class="n">Leaf</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">payload</span><span class="p">,</span>
        <span class="n">BinaryTree</span><span class="o">::</span><span class="n">Node</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="n">tree_weight_v1</span><span class="p">(</span><span class="o">*</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">payload</span> <span class="o">+</span> <span class="n">tree_weight_v1</span><span class="p">(</span><span class="o">*</span><span class="n">right</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// Returns tree that Looks like:</span>
<span class="c1">///</span>
<span class="c1">///      +----(4)---+</span>
<span class="c1">///      |          |</span>
<span class="c1">///   +-(2)-+      [5]</span>
<span class="c1">///   |     |</span>
<span class="c1">///  [1]   [3]</span>
<span class="c1">///</span>
<span class="n">fn</span> <span class="n">sample_tree</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">BinaryTree</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">BinaryTree</span><span class="o">::</span><span class="n">Leaf</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">let</span> <span class="n">l3</span> <span class="o">=</span> <span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">BinaryTree</span><span class="o">::</span><span class="n">Leaf</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
    <span class="n">let</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">BinaryTree</span><span class="o">::</span><span class="n">Node</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l3</span><span class="p">));</span>
    <span class="n">let</span> <span class="n">l5</span> <span class="o">=</span> <span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">BinaryTree</span><span class="o">::</span><span class="n">Leaf</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>

    <span class="n">BinaryTree</span><span class="o">::</span><span class="n">Node</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">l5</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="n">fn</span> <span class="n">tree_demo_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">sample_tree</span><span class="p">();</span>
    <span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">tree_weight_v1</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>代数数据类型构建结构不变量并被语言严格的加固.(即使更丰富的不变量表达式也可通过使用模块和私有控制进行维护, 但是这里就不进行过多关探讨)</p>
<h3>兼顾面向表达式和语句</h3>
<p>Rust 不像许多其它语言提供的模式匹配, 它同事涵盖了语句和表达式编程.</p>
<p>许多函数式编程语言提供的模式匹配鼓励书写面向表达式的编程风格. 这种方式聚焦于对表达式进行联合求值,并且不提倡引入 <a href="http://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8" target="_blank" >副作用</a>. 这和命令式编程相反. 命令式编程鼓励面向语句的编程风格, 关注仅仅为了产生副作用的的一序列命令.</p>
<p>Rust 在这两方面表现都很突出</p>
<p>思考写一个能够将非负数映射成字符串的函数, ("1st","2nd","3rd",...)</p>
<p>下面的代码使用 range 模式简化问题, 但是同时使用一种类似面向语句的 C(或者 C++, Java 等)语言里面的 switch 的风格. 这种方式 match 分支执行依赖于副作用.</p>
<div class="highlight"><pre><span class="n">fn</span> <span class="n">num_to_ordinal</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">u32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">suffix</span><span class="p">;</span>
    <span class="n">match</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">10</span><span class="p">,</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">21.</span><span class="p">.</span><span class="mf">.91</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s">&quot;st&quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">22.</span><span class="p">.</span><span class="mf">.92</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s">&quot;nd&quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">23.</span><span class="p">.</span><span class="mf">.93</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s">&quot;rd&quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">_</span>                     <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s">&quot;th&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}{}&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">suffix</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="n">fn</span> <span class="n">test_num_to_ordinal</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">num_to_ordinal</span><span class="p">(</span>   <span class="mi">0</span><span class="p">),</span>    <span class="s">&quot;0th&quot;</span><span class="p">);</span>
    <span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">num_to_ordinal</span><span class="p">(</span>   <span class="mi">1</span><span class="p">),</span>    <span class="s">&quot;1st&quot;</span><span class="p">);</span>
    <span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">num_to_ordinal</span><span class="p">(</span>  <span class="mi">12</span><span class="p">),</span>   <span class="s">&quot;12th&quot;</span><span class="p">);</span>
    <span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">num_to_ordinal</span><span class="p">(</span>  <span class="mi">22</span><span class="p">),</span>   <span class="s">&quot;22nd&quot;</span><span class="p">);</span>
    <span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">num_to_ordinal</span><span class="p">(</span>  <span class="mi">43</span><span class="p">),</span>   <span class="s">&quot;43rd&quot;</span><span class="p">);</span>
    <span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">num_to_ordinal</span><span class="p">(</span>  <span class="mi">67</span><span class="p">),</span>   <span class="s">&quot;67th&quot;</span><span class="p">);</span>
    <span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">num_to_ordinal</span><span class="p">(</span><span class="mi">1901</span><span class="p">),</span> <span class="s">&quot;1901st&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>很明显 Rust 编译器接受上面的程序,  它的静态分析能够保证:
<em>  suffix 总是在执行 format! 之前被初始化.并且
</em>  suffix 函数执行期间, suffix 至多被赋值一次(如果多次给 suffix 赋值, 编译器会强制我们标记 suffix 为 mutable)</p>
<p>可以明确的说, 上面的程序能够使用面向表达式的 Rust 编程风格, 比如这样:</p>
<div class="highlight"><pre><span class="n">fn</span> <span class="nf">num_to_ordinal_expr</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">u32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
    <span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}{}&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">match</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">10</span><span class="p">,</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">21.</span><span class="p">.</span><span class="mf">.91</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s">&quot;st&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">22.</span><span class="p">.</span><span class="mf">.92</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s">&quot;nd&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">23.</span><span class="p">.</span><span class="mf">.93</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s">&quot;rd&quot;</span><span class="p">,</span>
        <span class="n">_</span>                     <span class="o">=&gt;</span> <span class="s">&quot;th&quot;</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></div>


<p>一些时候面向表达式的风格可以生成非常精悍的代码. 另外一些时候, 这种风格需要各种变形. 然后面向语句的风格是可以避免的(前面 suggest_guess_fixed 能够从一个 match 分之返回就是一个例子)</p>
<p>每一种风格都有自己的应用场景. 重要的是, 切换到面向语句风格不会牺牲其它的特性. 比如可以保证一个非 mut 的绑定不会被多次赋值.</p>
<p>一个重要的情况是, 当想要去初始化一些状态, 并借出给特定部分控制流分支.</p>
<div class="highlight"><pre><span class="n">fn</span> <span class="nf">sometimes_initialize</span><span class="p">(</span><span class="n">input</span><span class="o">:</span> <span class="n">i32</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">string</span><span class="o">:</span> <span class="n">String</span><span class="p">;</span> <span class="c1">// a dynamically-constructed string value</span>
    <span class="n">let</span> <span class="n">borrowed</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">;</span> <span class="c1">// a reference to string data</span>
    <span class="n">match</span> <span class="n">input</span> <span class="p">{</span>
        <span class="mf">0.</span><span class="p">.</span><span class="mf">.100</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Construct a String on the fly...</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;input prints as {}&quot;</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
            <span class="c1">// ... and then borrow from inside it.</span>
            <span class="n">borrowed</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">string</span><span class="p">[</span><span class="mf">6.</span><span class="p">.];</span>
        <span class="p">}</span>
        <span class="n">_</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// String literals are *already* borrowed references</span>
            <span class="n">borrowed</span> <span class="o">=</span> <span class="s">&quot;expected between 0 and 100&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;borrowed: {}&quot;</span><span class="p">,</span> <span class="n">borrowed</span><span class="p">);</span>

    <span class="c1">// Below would cause compile-time error if uncommented...</span>

    <span class="c1">// println!(&quot;string: {}&quot;, string);</span>

    <span class="c1">// ...namely: error: use of possibly uninitialized variable: `string`</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="n">fn</span> <span class="nf">demo_sometimes_initialize</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">sometimes_initialize</span><span class="p">(</span><span class="mi">23</span><span class="p">);</span>  <span class="c1">// this invocation will initialize `string`</span>
    <span class="n">sometimes_initialize</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="c1">// this one will not</span>
<span class="p">}</span>
</pre></div>


<p>比较有意思的是上面代码在 match 结束之后, 不允许你直接的访问 string, 因为编译器要求变量必须可被访问之前在每一个路径都进行初始化. 与此同时,可以通过 borrowed 变量,访问 string 中持有的部分. 因为当执行第一个 match 分支的时候引用数据被 borrowed 持有, 我们能够保证 borrowed 是在从 match 开始直到使用 println! 的所有路径都是已初始化的.</p>
<p>(编译器保证没有借出的 string 能够超过 string 自己的生存期, 生成的代码保证在 string 的上下文结束处, 如果数据有初始化,该数据会被系狗叼 )</p>
<p>简言之, 为了合理性, Rust 语言保证数据在引用之前总是被初始化的, 但是设计者应当努力避人为的只是为了了通过 Rust 的静态分析的编码方法(比如要求使用一些皮包数据初始化上面的 string,, 或者要求面向表达式的风格)</p>
<h3>非 move match</h3>
<p>匹配输入可以借用输入值的子结构, 而且无需持有 ownershop, 这对于匹配引用(reference)来说是很重要的.</p>
<p>上面讲到的代数数据类型部分, 描述了一种树数据类型, 并展示如何计算树实例的数字总和.</p>
<p>然而那个版本的 tree_weight 函数有一个巨大的漏洞, 它按值获取输入的树. 一旦传入叔到 tree_weight_v1, 树就不存在了(在函数内部被释放内存)</p>
<div class="highlight"><pre><span class="cp">#[test]</span>
<span class="n">fn</span> <span class="nf">tree_demo_v1_fails</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">sample_tree</span><span class="p">();</span>
        <span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">tree_weight_v1</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>

    <span class="c1">// If you uncomment this line below ...</span>

    <span class="c1">// assert_eq!(tree_weight_v1(tree), (1 + 2 + 3) + 4 + 5);</span>

    <span class="c1">// ... you will get: error: use of moved value: `tree`</span>
<span class="p">}</span>
</pre></div>


<p>但是这并非是想要的 match 结果, 这更多是选用下面的函数的结果:</p>
<div class="highlight"><pre>    <span class="nx">fn</span> <span class="nx">tree_weight_v1</span><span class="p">(</span><span class="nx">t</span><span class="o">:</span> <span class="nx">BinaryTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">i32</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="c1">//                   ^~~~~~~~~~ this means this function takes ownership of `t`</span>
</pre></div>


<p>实际上, 在 Rust 中 match 设计成不需要持有输入的 ownership 就能工作的非常好. 尤其是当输入的匹配值是一个 <a href="https://doc.rust-lang.org/reference.html#lvalues,-rvalues-and-temporaries" target="_blank"> L-value </a>. 这意味着输入表达式被计算成输入值的内存地址. match 进行估值计算, 然后侦察内存地址中的数据.</p>
<p>(如果输入表达式是一个变量名或者字段/指针的解引用, L-value 只是变量或者字段/内存的地址. 如果输入表达式是函数调用,或者其他的生成未命名临时值, 它会被存储进一个临时地方, match 会定位监测该内存.)</p>
<p>因此当想要一个只是借用 tree 而不是持有 ownership 的 tree_weight 版本时, 就需要使用 match 的这个特性.</p>
<div class="highlight"><pre><span class="n">fn</span> <span class="nf">tree_weight_v2</span><span class="p">(</span><span class="n">t</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">BinaryTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i32</span> <span class="p">{</span>
    <span class="c1">//               ^~~~~~~~~~~ The `&amp;` means we are *borrowing* the tree</span>
    <span class="n">match</span> <span class="o">*</span><span class="n">t</span> <span class="p">{</span>
        <span class="n">BinaryTree</span><span class="o">::</span><span class="n">Leaf</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">payload</span><span class="p">,</span>
        <span class="n">BinaryTree</span><span class="o">::</span><span class="n">Node</span><span class="p">(</span><span class="n">ref</span> <span class="n">left</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">ref</span> <span class="n">right</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">tree_weight_v2</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">payload</span> <span class="o">+</span> <span class="n">tree_weight_v2</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="n">fn</span> <span class="n">tree_demo_2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">sample_tree</span><span class="p">();</span>
    <span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">tree_weight_v2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>tree_weight_v2 看起来很像 tree_weight_v1. 唯一的不同点是: 我们使用引用 t 作为一个 borrow 类型, 在 match 的时候添加解引用 *t,  然后重要的是在匹配 Node 的时候使用 ref 绑定到 left 和 right 子树.</p>
<p>对 <em>t 进行解引用, 编译器解释成一个 L-value 表达式, 然后只是提取 BinaryTree 内存地址(因为 t: &amp;BinaryTree 是一个引用到数据的内存). </em>t 在这里不会生成树的 copy, 也不会 moving 到一个新的临时地址, 因为 match 会把它当成是 L-value.</p>
<p>唯一剩下的 ref-binding 部分, 是 L-value 绑定解构造的关键.</p>
<p>首先, 严谨的表达下什么是 non-ref bingding:</p>
<ul>
<li>当使用模式变量 i 匹配类型 T 值, 匹配成功的时候, 会 move 原始输入到 i. 因此我们可以推断, 此时 i 是 T 类型的. (简单的说就是 i:T)</li>
</ul>
<p>对于一些 copyable 类型  T(读作实现了 Copy 的 T), T 值会被拷贝如 i.(注意 任意类型 T 不是 copyable)</p>
<p>另外, 这些模式绑定意味着, i 具有 T 值的 ownership.</p>
<p>这样,tree_weight_v2 中的 payload 绑定具有 i32 类型, i32 类型实现了 Copy , 因此在所有分之 weight 都会被拷贝入 payload.</p>
<p>现在可以说一说什么是 ref-binding</p>
<ul>
<li>当成功匹配到 L-value 类型 T, ref 模式 ref i 会只是借出引用到匹配到的数据中. 或者说, 成功的 ref i 匹配 T 值意味着 i 具有 T 类型的引用(简单说就是 i :&amp;T)</li>
</ul>
<p>这样, tree_weight_v2 中的结点匹配分支, left 会引用到一个左子树, right 会相同的引用到右子树.</p>
<p>可以传递这些树的借出引用 （borrowed reference） 到到递归调用函数  tree_weight_v2 中,就像代码中演示的那样.</p>
<p>相同的, 一个 ref mut 模式(ref mut i)会在匹配成功之后, 借用 input 的一个 mutable 引用到 i: &amp;mut T. 这就可以修改, 并保证同时没有其它激活的引用. 像 match 这样解构绑定的方式, 允许对可变(mutable)引用进行部分分解.</p>
<p>下面代码演示通过增加给出的树的值验证这种概念</p>
<div class="highlight"><pre><span class="n">fn</span> <span class="nf">tree_grow</span><span class="p">(</span><span class="n">t</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">mut</span> <span class="n">BinaryTree</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//          ^~~~~~~~~~~~~~~ `&amp;mut`: we have exclusive access to the tree</span>
    <span class="n">match</span> <span class="o">*</span><span class="n">t</span> <span class="p">{</span>
        <span class="n">BinaryTree</span><span class="o">::</span><span class="n">Leaf</span><span class="p">(</span><span class="n">ref</span> <span class="n">mut</span> <span class="n">payload</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">*</span><span class="n">payload</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">BinaryTree</span><span class="o">::</span><span class="n">Node</span><span class="p">(</span><span class="n">ref</span> <span class="n">mut</span> <span class="n">left</span><span class="p">,</span> <span class="n">ref</span> <span class="n">mut</span> <span class="n">payload</span><span class="p">,</span> <span class="n">ref</span> <span class="n">mut</span> <span class="n">right</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">tree_grow</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
            <span class="o">*</span><span class="n">payload</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">tree_grow</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[test]</span>
<span class="n">fn</span> <span class="nf">tree_demo_3</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">mut</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">sample_tree</span><span class="p">();</span>
    <span class="n">tree_grow</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mut</span> <span class="n">tree</span><span class="p">);</span>
        <span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">tree_weight_v2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">6</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>注意, 上面的代码按照 ref-mut 模式绑定 payload,如果不实用 ref 模式, payload 回绑定到一个局部的 integer 拷贝上. 如果我们想修改实际树中的 integer ,我们需要引用到那个 integer.</p>
<p>注意在 Node 分支中代码能够同时绑定到 left 和 right . 编译器知道这两个值不同, 因此可以同时允许 &amp;mut 引用存在.(这块没看太懂, 原文是这样的 The compiler knows that the two values cannot alias, and thus it allows both &amp;mut-references to live simultaneously.)</p>
<h3>总结</h3>
<p>Rust 使用函数式编程中的先驱思想:代数数据类型和模式匹配. 并做了修改, 使之能够用在命令式编程以及 Rust 独有的 ownership 和 borrow 系统上. enum 和 match 形式提供了清晰的数据定义和强表达力. 同时静态分析能够保证程序结果的安全性.
这里没有涉及到的更多细节有:</p>
<ul>
<li>如何在模式中使用 Higher 替代 Answer::Higher</li>
<li>定义命名常量</li>
<li>通过 indent @ pattern 绑定</li>
<li>{let id = expr; ...} 对比 match expr {id =&gt; {...} }之间的微小差别.</li>
</ul>
<p>查阅 Rust <a href="https://doc.rust-lang.org/" target="_blank">文档</a> 或者咨询我们的团队 ( IRC #rust, 或 <a href="http://users.rust-lang.org/" target="_blank"> 用户群 </a>)</p>
<p>(多谢帮助我审校文章的朋友: 尤其是 Aaron Turon 和 Niko Matsakis, 以及来自 #rust 的  Mutabah, proc, libfud, asQuirrel 和 annodomini)</p>
<p><a href="rust-lang.org" target="_blank">更多关于 Rust</a> -- <a href="http://doc.rust-lang.org/book/index.html" target="_blank">直接跳转</a></p>
            
            
            <hr/>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2015-05-06T00:00:00">May 6, 2015</time>
            <h4>Category</h4>
            <a class="category-link" href="/categories.html#rust-ref">rust</a>


	    <!-- 多说评论框 start -->
	    <div class="ds-thread" data-thread-key="1" data-title="Rust Means Never Having to Close a Socket" data-url="Rust Means Never Having to Close a Socket"></div>
	    <!-- 多说评论框 end -->
	    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	    <script type="text/javascript">
	    var duoshuoQuery = {short_name:"rustup"};
(function() {
 var ds = document.createElement('script');
 ds.type = 'text/javascript';ds.async = true;
 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
 ds.charset = 'UTF-8';
 (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
 })();
</script>
<!-- 多说公共JS代码 end -->


<h4>Contact</h4>
    <a href="#" title="My You can add links in your config file Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-you can add links in your config file sidebar-social-links"></i></a>
    <a href="#" title="My Another social link Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-another social link sidebar-social-links"></i></a>
        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
        <div id="push"></div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>            <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    
    </body>
    <!-- Theme: Elegant built for Pelican
    License : http://oncrashreboot.com/pelican-elegant -->
</html>